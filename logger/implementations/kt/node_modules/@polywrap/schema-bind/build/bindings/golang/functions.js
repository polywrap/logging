"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgName = exports.toUpper = exports.toFirstLower = exports.toLower = exports.toWasm = exports.toMsgPack = exports.handleKeywords = exports.stuctProps = exports.makeImports = exports.toSnakeCase = exports.readPointer = exports.writePointer = exports.lastFullIter = exports.prevFullIter = exports.nextIter = exports.currIter = exports.stopIter = exports.startIter = void 0;
var reservedWords_1 = require("./reservedWords");
var num = -1;
var startIter = function () {
    return function () {
        num = -1;
        return "";
    };
};
exports.startIter = startIter;
var stopIter = function () {
    return function () {
        num = -1;
        return "";
    };
};
exports.stopIter = stopIter;
var currIter = function () {
    return function (text, render) {
        var rendered = render(text);
        return "".concat(rendered).concat(num);
    };
};
exports.currIter = currIter;
var nextIter = function () {
    return function (text, render) {
        var rendered = render(text);
        return "".concat(rendered).concat(++num);
    };
};
exports.nextIter = nextIter;
var prevFullIter = function () {
    return function (text, render) {
        var rendered = render(text);
        if (rendered == "stop") {
            return "";
        }
        return Array(num)
            .fill(0)
            .map(function (_, i) { return "[".concat(rendered).concat(i, "]"); })
            .join("");
    };
};
exports.prevFullIter = prevFullIter;
var lastFullIter = function () {
    return function (text, render) {
        var rendered = render(text);
        if (rendered == "stop") {
            return "";
        }
        return Array(num + 1)
            .fill(0)
            .map(function (_, i) { return "[".concat(rendered).concat(i, "]"); })
            .join("");
    };
};
exports.lastFullIter = lastFullIter;
var writePointer = function () {
    return function (text, render) {
        var _a = __read(render(text).split(" - "), 2), type = _a[0], value = _a[1];
        var pointer = "*";
        switch (type) {
            case "BigInt":
            case "Json":
            case "Bytes":
                pointer = "";
                break;
        }
        return "writer.Write".concat(type, "(").concat(pointer).concat(value, ")");
    };
};
exports.writePointer = writePointer;
var readPointer = function () {
    return function (text, render) {
        var _a = __read(render(text).split(" - "), 2), type = _a[0], value = _a[1];
        var pointer = "&";
        switch (type) {
            case "BigInt":
            case "Json":
            case "Bytes":
                pointer = "";
                break;
        }
        return "".concat(pointer).concat(value);
    };
};
exports.readPointer = readPointer;
var toSnakeCase = function () {
    return function (text, render) {
        text = render(text).replace(/([A-Z])/g, "_$1");
        text = text.startsWith("_") ? text.slice(1) : text;
        return text.toLowerCase();
    };
};
exports.toSnakeCase = toSnakeCase;
var makeImports = function () {
    return function (text, render) {
        var e_1, _a;
        var types = render(text).split(",");
        var exist = {};
        try {
            for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
                var t = types_1_1.value;
                t = t.trim();
                if (t.endsWith("big.Int")) {
                    exist["github.com/polywrap/go-wrap/msgpack/big"] = true;
                }
                else if (t.endsWith("fastjson.Value")) {
                    exist["github.com/valyala/fastjson"] = true;
                }
                else if (/([^/\s]+\/)(.*)/.test(t)) {
                    exist[t] = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var imports = [];
        imports.push.apply(imports, __spreadArray([], __read(Object.keys(exist)), false));
        var txt = imports
            .sort()
            .map(function (imp) {
            var res = "";
            if (imp.startsWith(". ")) {
                res = ". \"".concat(imp.slice(2), "\"");
            }
            else {
                var parts = imp.split(" as ");
                if (parts.length > 1) {
                    res = "".concat(parts[1], " \"").concat(parts[0], "\"");
                }
                else {
                    res = "\"".concat(imp, "\"");
                }
            }
            return "\t".concat(res);
        })
            .join("\n");
        return txt !== "" ? "\nimport (\n".concat(txt, "\n)\n\n") : "\n";
    };
};
exports.makeImports = makeImports;
var stuctProps = function () {
    return function (text, render) {
        var e_2, _a;
        var props = render(text)
            .split("\n")
            .map(function (line) { return line.trimEnd(); })
            .filter(function (line) { return line !== ""; })
            .map(function (line) { return line.split(" "); });
        var maxPropNameLn = 0;
        try {
            for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                var _b = __read(props_1_1.value, 1), propName = _b[0];
                if (propName.length > maxPropNameLn) {
                    maxPropNameLn = propName.length;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        for (var i = 0; i < props.length; i++) {
            if (props[i][0].length < maxPropNameLn) {
                props[i][0] += Array(maxPropNameLn - props[i][0].length)
                    .fill(" ")
                    .join("");
            }
            props[i][0] = "\t" + props[i][0];
        }
        return props.map(function (v) { return v.join(" "); }).join("\n") + "\n";
    };
};
exports.stuctProps = stuctProps;
var handleKeywords = function () {
    return function (text, render) {
        var rendered = render(text);
        if (reservedWords_1.reservedWordsAS.has(rendered)) {
            return "m_" + rendered;
        }
        return rendered;
    };
};
exports.handleKeywords = handleKeywords;
var toMsgPack = function () {
    return function (value, render) {
        var type = render(value);
        if (type[type.length - 1] === "!") {
            type = type.substring(0, type.length - 1);
        }
        var t = type;
        if (type.startsWith("[")) {
            t = "Array";
        }
        else if (type.startsWith("Map")) {
            t = "Map";
        }
        else if (type.startsWith("Int8")) {
            t = "I8";
        }
        else if (type.startsWith("Int16")) {
            t = "I16";
        }
        else if (type.startsWith("Int32")) {
            t = "I32";
        }
        else if (type.startsWith("Int64")) {
            t = "I64";
        }
        else if (type.startsWith("Int")) {
            t = "I32";
        }
        else if (type.startsWith("UInt8")) {
            t = "U8";
        }
        else if (type.startsWith("UInt16")) {
            t = "U16";
        }
        else if (type.startsWith("UInt32")) {
            t = "U32";
        }
        else if (type.startsWith("UInt64")) {
            t = "U64";
        }
        else if (type.startsWith("UInt")) {
            t = "U32";
        }
        else if (type.startsWith("String")) {
            t = "String";
        }
        else if (type.startsWith("Boolean")) {
            t = "Bool";
        }
        else if (type.startsWith("Bytes")) {
            t = "Bytes";
        }
        else if (type.startsWith("BigInt")) {
            t = "BigInt";
        }
        else if (type.startsWith("BigNumber")) {
            t = "BigInt";
        }
        else if (type.startsWith("JSON")) {
            t = "Json";
        }
        return t;
    };
};
exports.toMsgPack = toMsgPack;
var toWasm = function () {
    return function (value, render) {
        var type = render(value);
        var isEnum = false;
        var optional = false;
        if (type[type.length - 1] === "!") {
            type = type.substring(0, type.length - 1);
        }
        else {
            optional = true;
        }
        if (type[0] === "[") {
            return toWasmArray(type, optional);
        }
        if (type.startsWith("Map<")) {
            return toWasmMap(type, optional);
        }
        switch (type) {
            case "Int":
                type = "int32";
                break;
            case "Int8":
                type = "int8";
                break;
            case "Int16":
                type = "int16";
                break;
            case "Int32":
                type = "int32";
                break;
            case "Int64":
                type = "int64";
                break;
            case "UInt":
                type = "uint32";
                break;
            case "UInt8":
                type = "uint8";
                break;
            case "UInt16":
                type = "uint16";
                break;
            case "UInt32":
                type = "uint32";
                break;
            case "UInt64":
                type = "uint64";
                break;
            case "String":
                type = "string";
                break;
            case "Boolean":
                type = "bool";
                break;
            case "Bytes":
                type = "[]byte";
                break;
            case "BigInt":
                type = "*big.Int";
                break;
            case "BigNumber":
                type = "*big.Int";
                break;
            case "JSON":
                type = "*fastjson.Value";
                break;
            default:
                if (type.includes("Enum_")) {
                    type = "".concat(type.replace("Enum_", ""));
                    isEnum = true;
                }
                else {
                    type = type.charAt(0).toUpperCase() + type.slice(1);
                }
        }
        return applyOptional(type, optional, isEnum);
    };
};
exports.toWasm = toWasm;
var toWasmArray = function (type, optional) {
    var result = type.match(/(\[)([[\]A-Za-z0-9_.!]+)(\])/);
    if (!result || result.length !== 4) {
        throw Error("Invalid Array: ".concat(type));
    }
    var wasmType = (0, exports.toWasm)()(result[2], function (str) { return str; });
    return applyOptional("[]".concat(wasmType), optional, false);
};
var toWasmMap = function (type, optional) {
    var firstOpenBracketIdx = type.indexOf("<");
    var lastCloseBracketIdx = type.lastIndexOf(">");
    if (!(firstOpenBracketIdx !== -1 && lastCloseBracketIdx !== -1)) {
        throw new Error("Invalid Map: ".concat(type));
    }
    var keyValTypes = type
        .substring(firstOpenBracketIdx + 1, lastCloseBracketIdx)
        .split(",");
    if (keyValTypes.length < 2) {
        throw new Error("Invalid Map: ".concat(type));
    }
    var keyType = (0, exports.toWasm)()(keyValTypes[0].trim(), function (str) { return str; });
    var valType = (0, exports.toWasm)()(keyValTypes.slice(1).join(",").trim(), function (str) { return str; });
    return applyOptional("map[".concat(keyType, "]").concat(valType), optional, false);
};
var applyOptional = function (type, optional, _) {
    if (optional &&
        !type.startsWith("*") &&
        !type.startsWith("[]") &&
        !type.startsWith("map")) {
        return "*".concat(type);
    }
    else {
        return type;
    }
};
var toLower = function () {
    return function (value, render) {
        return render(value)
            .split("")
            .map(function (v) { return v.toLowerCase(); })
            .join("");
    };
};
exports.toLower = toLower;
var toFirstLower = function () {
    return function (value, render) {
        var type = render(value);
        return type.charAt(0).toLowerCase() + type.slice(1);
    };
};
exports.toFirstLower = toFirstLower;
var toUpper = function () {
    return function (value, render) {
        var type = render(value);
        return type.charAt(0).toUpperCase() + type.slice(1);
    };
};
exports.toUpper = toUpper;
var pkgName = function () {
    return function (text, render) {
        var name = render(text);
        return reservedWords_1.reservedWordsAS.has(name) ? "pkg".concat(name) : name;
    };
};
exports.pkgName = pkgName;
//# sourceMappingURL=functions.js.map