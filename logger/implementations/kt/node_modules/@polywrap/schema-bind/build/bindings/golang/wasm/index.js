"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBinding = void 0;
var __1 = require("../");
var __2 = require("../..");
var utils_1 = require("../../utils");
var reservedWords_1 = require("../reservedWords");
var Transforms = __importStar(require("../transforms"));
var schema_parse_1 = require("@polywrap/schema-parse");
var os_js_1 = require("@polywrap/os-js");
var path_1 = __importDefault(require("path"));
var templatesDir = (0, os_js_1.readDirectorySync)(path_1.default.join(__dirname, "./templates"));
var subTemplates = (0, utils_1.loadSubTemplates)(templatesDir.entries);
var templatePath = function (subpath) {
    return path_1.default.join(__dirname, "./templates", subpath);
};
function pkgName(str) {
    return reservedWords_1.reservedWordsAS.has(str) ? "pkg".concat(str) : str;
}
function camel2snake(str) {
    str = str.replace(/([A-Z])/g, "_$1");
    str = str.startsWith("_") ? str.slice(1) : str;
    return str.toLowerCase();
}
var generateBinding = function (options) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f, e_7, _g, _h;
    var _j, _k;
    var result = {
        output: {
            entries: [],
        },
        outputDirAbs: options.outputDirAbs,
    };
    var output = result.output;
    var abi = applyTransforms(options.wrapInfo.abi);
    var goImport = (_j = options.config) === null || _j === void 0 ? void 0 : _j.goModuleName;
    if (!goImport) {
        throw Error("wasm/golang bindings requires the config property 'goModuleName' to be set");
    }
    // Generate object type folders
    if (abi.objectTypes) {
        try {
            for (var _l = __values(abi.objectTypes), _m = _l.next(); !_m.done; _m = _l.next()) {
                var objectType = _m.value;
                output.entries.push({
                    type: "Directory",
                    name: "types",
                    data: (0, __2.renderTemplates)(templatePath("object-type"), objectType, subTemplates),
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // Generate imported folder
    var importEntries = [];
    // Generate imported module type folders
    if (abi.importedModuleTypes) {
        try {
            for (var _o = __values(abi.importedModuleTypes), _p = _o.next(); !_p.done; _p = _o.next()) {
                var importedModuleType = _p.value;
                importEntries.push({
                    type: "Directory",
                    name: "".concat(pkgName(camel2snake(importedModuleType.namespace))),
                    data: (0, __2.renderTemplates)(templatePath("imported/module-type"), importedModuleType, subTemplates),
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_p && !_p.done && (_b = _o.return)) _b.call(_o);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // // Generate imported env type folders
    if (abi.importedEnvTypes) {
        try {
            for (var _q = __values(abi.importedEnvTypes), _r = _q.next(); !_r.done; _r = _q.next()) {
                var importedEnvType = _r.value;
                importEntries.push({
                    type: "Directory",
                    name: "".concat(pkgName(camel2snake(importedEnvType.namespace))),
                    data: (0, __2.renderTemplates)(templatePath("imported/env-type"), importedEnvType, subTemplates),
                });
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_r && !_r.done && (_c = _q.return)) _c.call(_q);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    // Generate imported enum type folders
    if (abi.importedEnumTypes) {
        try {
            for (var _s = __values(abi.importedEnumTypes), _t = _s.next(); !_t.done; _t = _s.next()) {
                var importedEnumType = _t.value;
                importEntries.push({
                    type: "Directory",
                    name: "".concat(pkgName(camel2snake(importedEnumType.namespace))),
                    data: (0, __2.renderTemplates)(templatePath("imported/enum-type"), importedEnumType, subTemplates),
                });
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_t && !_t.done && (_d = _s.return)) _d.call(_s);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    // Generate imported object type folders
    if (abi.importedObjectTypes) {
        try {
            for (var _u = __values(abi.importedObjectTypes), _v = _u.next(); !_v.done; _v = _u.next()) {
                var importedObectType = _v.value;
                importEntries.push({
                    type: "Directory",
                    name: "".concat(pkgName(camel2snake(importedObectType.namespace))),
                    data: (0, __2.renderTemplates)(templatePath("imported/object-type"), importedObectType, subTemplates),
                });
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_v && !_v.done && (_e = _u.return)) _e.call(_u);
            }
            finally { if (e_5) throw e_5.error; }
        }
    }
    if (importEntries.length) {
        output.entries.push({
            type: "Directory",
            name: "imported",
            data: __spreadArray(__spreadArray([], __read(importEntries), false), __read((0, __2.renderTemplates)(templatePath("imported"), abi, subTemplates)), false),
        });
    }
    // Generate interface type folders
    if (abi.interfaceTypes) {
        try {
            for (var _w = __values(abi.interfaceTypes), _x = _w.next(); !_x.done; _x = _w.next()) {
                var interfaceType = _x.value;
                output.entries.push({
                    type: "Directory",
                    name: "interfaces",
                    data: (0, __2.renderTemplates)(templatePath("interface-type"), interfaceType, subTemplates),
                });
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_x && !_x.done && (_f = _w.return)) _f.call(_w);
            }
            finally { if (e_6) throw e_6.error; }
        }
    }
    // Generate module type folders
    if (abi.moduleType) {
        var imports_1 = {};
        (_k = abi.moduleType.methods) === null || _k === void 0 ? void 0 : _k.forEach(function (method) {
            var _a;
            (_a = method.arguments) === null || _a === void 0 ? void 0 : _a.forEach(function (arg) {
                var _a;
                var tp = (_a = abi.importedObjectTypes) === null || _a === void 0 ? void 0 : _a.find(function (mt) {
                    return mt.type === arg.type;
                });
                if (tp) {
                    imports_1[tp.namespace] = true;
                }
            });
        });
        var importedTypes = Object.keys(imports_1).map(function (namespace) { return ({
            namespace: namespace,
        }); });
        output.entries.push({
            type: "Directory",
            name: "types",
            data: (0, __2.renderTemplates)(templatePath("module-type/types"), __assign({ importedTypes: importedTypes, goImport: goImport }, abi.moduleType), subTemplates),
        });
        output.entries.push({
            type: "Directory",
            name: "module_wrapped",
            data: (0, __2.renderTemplates)(templatePath("module-type/module_wrapped"), __assign({ importedTypes: importedTypes, goImport: goImport }, abi.moduleType), subTemplates),
        });
    }
    // Generate enum type folders
    if (abi.enumTypes) {
        try {
            for (var _y = __values(abi.enumTypes), _z = _y.next(); !_z.done; _z = _y.next()) {
                var enumType = _z.value;
                output.entries.push({
                    type: "Directory",
                    name: "types",
                    data: (0, __2.renderTemplates)(templatePath("enum-type"), enumType, subTemplates),
                });
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_z && !_z.done && (_g = _y.return)) _g.call(_y);
            }
            finally { if (e_7) throw e_7.error; }
        }
    }
    // Generate env type folders
    if (abi.envType) {
        output.entries.push({
            type: "Directory",
            name: "types",
            data: (0, __2.renderTemplates)(templatePath("object-type"), abi.envType, subTemplates),
        });
    }
    // Generate root entry file
    output.entries.push({
        type: "Directory",
        name: "main",
        data: (0, __2.renderTemplates)(templatePath("main"), __assign({ goImport: goImport }, abi), subTemplates),
    });
    // Render the root directory
    (_h = output.entries).push.apply(_h, __spreadArray([], __read((0, __2.renderTemplates)(templatePath(""), __assign({ goImport: goImport }, abi), subTemplates)), false));
    output.entries = mergePaths(output.entries);
    return result;
};
exports.generateBinding = generateBinding;
function mergePaths(array) {
    var _a;
    var tmp = {};
    for (var i = 0; i < array.length; i++) {
        switch (array[i].type) {
            case "File":
                tmp[array[i].name] = array[i];
                break;
            case "Directory":
                if (!tmp[array[i].name]) {
                    tmp[array[i].name] = array[i];
                }
                else {
                    (_a = tmp[array[i].name].data).push.apply(_a, __spreadArray([], __read(array[i].data), false));
                }
                break;
        }
    }
    array = Object.values(tmp);
    for (var i = 0; i < array.length; i++) {
        if (array[i].type === "Directory") {
            array[i].data = mergePaths(array[i].data);
        }
    }
    return array;
}
function applyTransforms(abi) {
    var e_8, _a;
    var transforms = [
        (0, schema_parse_1.extendType)(__1.Functions),
        schema_parse_1.addFirstLast,
        schema_parse_1.toPrefixedGraphQLType,
        Transforms.extractImportedTypes(),
        Transforms.extractNeededImportedNamespaces(),
        Transforms.needsImportedNamespaces(),
        Transforms.moduleNeedsTypes(),
    ];
    try {
        for (var transforms_1 = __values(transforms), transforms_1_1 = transforms_1.next(); !transforms_1_1.done; transforms_1_1 = transforms_1.next()) {
            var transform = transforms_1_1.value;
            abi = (0, schema_parse_1.transformAbi)(abi, transform);
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (transforms_1_1 && !transforms_1_1.done && (_a = transforms_1.return)) _a.call(transforms_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return abi;
}
//# sourceMappingURL=index.js.map