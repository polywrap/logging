import { Wrapper, CoreClient, GetFileOptions, GetImplementationsOptions, InvokerOptions, Uri, TryResolveUriOptions, IUriResolver, IUriResolutionContext, UriPackageOrWrapper, InvokeResult, CoreClientConfig, WrapError, WrapperEnv, ReadonlyUriMap } from "@polywrap/core-js";
import { DeserializeManifestOptions, WrapManifest } from "@polywrap/wrap-manifest-types-js";
import { Result } from "@polywrap/result";
export declare class PolywrapCoreClient implements CoreClient {
    private _config;
    /**
     * Instantiate a PolywrapClient
     *
     * @param config - a core client configuration
     */
    constructor(_config: CoreClientConfig);
    /**
     * Returns the configuration used to instantiate the client
     *
     * @returns an immutable Polywrap client config
     */
    getConfig(): CoreClientConfig;
    /**
     * returns all interfaces from the configuration used to instantiate the client
     *
     * @returns an array of interfaces and their registered implementations
     */
    getInterfaces(): ReadonlyUriMap<readonly Uri[]> | undefined;
    /**
     * returns all env registrations from the configuration used to instantiate the client
     *
     * @returns an array of env objects containing wrapper environmental variables
     */
    getEnvs(): ReadonlyUriMap<WrapperEnv> | undefined;
    /**
     * returns the URI resolver from the configuration used to instantiate the client
     *
     * @returns an object that implements the IUriResolver interface
     */
    getResolver(): IUriResolver<unknown>;
    /**
     * returns an env (a set of environmental variables) from the configuration used to instantiate the client
     *
     * @param uri - the URI used to register the env
     * @returns an env, or undefined if an env is not found at the given URI
     */
    getEnvByUri(uri: Uri): WrapperEnv | undefined;
    /**
     * returns a package's wrap manifest
     *
     * @param uri - a wrap URI
     * @returns a Result containing the WrapManifest if the request was successful
     */
    getManifest(uri: Uri): Promise<Result<WrapManifest, WrapError>>;
    /**
     * returns a file contained in a wrap package
     *
     * @param uri - a wrap URI
     * @param options - { path: string; encoding?: "utf-8" | string }
     * @returns a Promise of a Result containing a file if the request was successful
     */
    getFile(uri: Uri, options: GetFileOptions): Promise<Result<string | Uint8Array, WrapError>>;
    /**
     * returns the interface implementations associated with an interface URI
     *  from the configuration used to instantiate the client
     *
     * @param uri - a wrap URI
     * @param options - { applyResolution?: boolean; resolutionContext?: IUriResolutionContext }
     * @returns a Result containing URI array if the request was successful
     */
    getImplementations(uri: Uri, options?: GetImplementationsOptions): Promise<Result<Uri[], WrapError>>;
    /**
     * Invoke a wrapper using an instance of the wrapper.
     *
     * @param options - {
     *   // The Wrapper's URI
     *   uri: TUri;
     *
     *   // Method to be executed.
     *   method: string;
     *
     *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordered arguments.
     *    args?: Record<string, unknown> | Uint8Array;
     *
     *   // Env variables for the wrapper invocation.
     *    env?: Record<string, unknown>;
     *
     *   // A Uri resolution context
     *   resolutionContext?: IUriResolutionContext;
     *
     *   // if true, return value is a msgpack-encoded byte array
     *   encodeResult?: boolean;
     *
     *   // The wrapper to invoke
     *   wrapper: Wrapper
     * }
     * @returns A Promise with a Result containing the return value or an error
     */
    invokeWrapper<TData = unknown>(options: InvokerOptions & {
        wrapper: Wrapper;
    }): Promise<InvokeResult<TData>>;
    /**
     * Invoke a wrapper.
     *
     * @remarks
     * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper.
     *
     * @param options - {
     *   // The Wrapper's URI
     *   uri: TUri;
     *
     *   // Method to be executed.
     *   method: string;
     *
     *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordered arguments.
     *    args?: Record<string, unknown> | Uint8Array;
     *
     *   // Env variables for the wrapper invocation.
     *    env?: Record<string, unknown>;
     *
     *   // A Uri resolution context
     *   resolutionContext?: IUriResolutionContext;
     *
     *   // if true, return value is a msgpack-encoded byte array
     *   encodeResult?: boolean;
     * }
     * @returns A Promise with a Result containing the return value or an error
     */
    invoke<TData = unknown>(options: InvokerOptions): Promise<InvokeResult<TData>>;
    /**
     * Resolve a URI to a wrap package, a wrapper, or a uri
     *
     * @param options - { uri: TUri; resolutionContext?: IUriResolutionContext }
     * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful
     */
    tryResolveUri(options: TryResolveUriOptions): Promise<Result<UriPackageOrWrapper, unknown>>;
    /**
     * Resolve a URI to a wrap package or wrapper.
     * If the URI resolves to wrap package, load the wrapper.
     *
     * @remarks
     * Unlike other methods, `loadWrapper` does not accept a string URI.
     * You can create a Uri (from the `@polywrap/core-js` package) using `Uri.from("wrap://...")`
     *
     * @param uri - the Uri to resolve
     * @param resolutionContext? - a resolution context
     * @param options - { noValidate?: boolean }
     * @returns A Promise with a Result containing a Wrapper or Error
     */
    loadWrapper(uri: Uri, resolutionContext?: IUriResolutionContext, options?: DeserializeManifestOptions): Promise<Result<Wrapper, WrapError>>;
}
