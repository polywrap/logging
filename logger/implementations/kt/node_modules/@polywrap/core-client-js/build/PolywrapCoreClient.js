"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolywrapCoreClient = void 0;
var core_js_1 = require("@polywrap/core-js");
var msgpack_js_1 = require("@polywrap/msgpack-js");
var result_1 = require("@polywrap/result");
var PolywrapCoreClient = /** @class */ (function () {
    // $start: PolywrapCoreClient-constructor
    /**
     * Instantiate a PolywrapClient
     *
     * @param config - a core client configuration
     */
    function PolywrapCoreClient(_config) {
        this._config = _config;
    }
    // $start: PolywrapCoreClient-getConfig
    /**
     * Returns the configuration used to instantiate the client
     *
     * @returns an immutable Polywrap client config
     */
    PolywrapCoreClient.prototype.getConfig = function () {
        return this._config;
    };
    // $start: PolywrapCoreClient-getInterfaces
    /**
     * returns all interfaces from the configuration used to instantiate the client
     *
     * @returns an array of interfaces and their registered implementations
     */
    PolywrapCoreClient.prototype.getInterfaces = function () {
        return this._config.interfaces;
    };
    // $start: PolywrapCoreClient-getEnvs
    /**
     * returns all env registrations from the configuration used to instantiate the client
     *
     * @returns an array of env objects containing wrapper environmental variables
     */
    PolywrapCoreClient.prototype.getEnvs = function () {
        return this._config.envs;
    };
    // $start: PolywrapCoreClient-getResolver
    /**
     * returns the URI resolver from the configuration used to instantiate the client
     *
     * @returns an object that implements the IUriResolver interface
     */
    PolywrapCoreClient.prototype.getResolver = function () {
        return this._config.resolver;
    };
    // $start: PolywrapCoreClient-getEnvByUri
    /**
     * returns an env (a set of environmental variables) from the configuration used to instantiate the client
     *
     * @param uri - the URI used to register the env
     * @returns an env, or undefined if an env is not found at the given URI
     */
    PolywrapCoreClient.prototype.getEnvByUri = function (uri) {
        var envs = this.getEnvs();
        if (!envs) {
            return undefined;
        }
        return envs.get(uri);
    };
    // $start: PolywrapCoreClient-getManifest
    /**
     * returns a package's wrap manifest
     *
     * @param uri - a wrap URI
     * @returns a Result containing the WrapManifest if the request was successful
     */
    PolywrapCoreClient.prototype.getManifest = function (uri) {
        return __awaiter(this, void 0, void 0, function () {
            var load, wrapper, manifest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadWrapper(core_js_1.Uri.from(uri), undefined)];
                    case 1:
                        load = _a.sent();
                        if (!load.ok) {
                            return [2 /*return*/, load];
                        }
                        wrapper = load.value;
                        manifest = wrapper.getManifest();
                        return [2 /*return*/, (0, result_1.ResultOk)(manifest)];
                }
            });
        });
    };
    // $start: PolywrapCoreClient-getFile
    /**
     * returns a file contained in a wrap package
     *
     * @param uri - a wrap URI
     * @param options - { path: string; encoding?: "utf-8" | string }
     * @returns a Promise of a Result containing a file if the request was successful
     */
    PolywrapCoreClient.prototype.getFile = function (uri, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var load, wrapper, result, error;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.loadWrapper(core_js_1.Uri.from(uri), undefined)];
                    case 1:
                        load = _b.sent();
                        if (!load.ok) {
                            return [2 /*return*/, load];
                        }
                        wrapper = load.value;
                        return [4 /*yield*/, wrapper.getFile(options)];
                    case 2:
                        result = _b.sent();
                        if (!result.ok) {
                            error = new core_js_1.WrapError((_a = result.error) === null || _a === void 0 ? void 0 : _a.message, {
                                code: core_js_1.WrapErrorCode.CLIENT_GET_FILE_ERROR,
                                uri: uri.toString(),
                            });
                            return [2 /*return*/, (0, result_1.ResultErr)(error)];
                        }
                        return [2 /*return*/, (0, result_1.ResultOk)(result.value)];
                }
            });
        });
    };
    // $start: PolywrapCoreClient-getImplementations
    /**
     * returns the interface implementations associated with an interface URI
     *  from the configuration used to instantiate the client
     *
     * @param uri - a wrap URI
     * @param options - { applyResolution?: boolean; resolutionContext?: IUriResolutionContext }
     * @returns a Result containing URI array if the request was successful
     */
    PolywrapCoreClient.prototype.getImplementations = function (uri, options) {
        var _a;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var applyResolution, getImplResult, uris;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        applyResolution = !!options.applyResolution;
                        return [4 /*yield*/, (0, core_js_1.getImplementations)(core_js_1.Uri.from(uri), (_a = this.getInterfaces()) !== null && _a !== void 0 ? _a : new core_js_1.UriMap(), applyResolution ? this : undefined, applyResolution ? options.resolutionContext : undefined)];
                    case 1:
                        getImplResult = _b.sent();
                        if (!getImplResult.ok) {
                            return [2 /*return*/, getImplResult];
                        }
                        uris = getImplResult.value;
                        return [2 /*return*/, (0, result_1.ResultOk)(uris)];
                }
            });
        });
    };
    // $start: PolywrapCoreClient-invokeWrapper
    /**
     * Invoke a wrapper using an instance of the wrapper.
     *
     * @param options - {
     *   // The Wrapper's URI
     *   uri: TUri;
     *
     *   // Method to be executed.
     *   method: string;
     *
     *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordered arguments.
     *    args?: Record<string, unknown> | Uint8Array;
     *
     *   // Env variables for the wrapper invocation.
     *    env?: Record<string, unknown>;
     *
     *   // A Uri resolution context
     *   resolutionContext?: IUriResolutionContext;
     *
     *   // if true, return value is a msgpack-encoded byte array
     *   encodeResult?: boolean;
     *
     *   // The wrapper to invoke
     *   wrapper: Wrapper
     * }
     * @returns A Promise with a Result containing the return value or an error
     */
    PolywrapCoreClient.prototype.invokeWrapper = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var typedOptions, wrapper, invocableResult, value, encoded, decoded, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        typedOptions = __assign(__assign({}, options), { uri: core_js_1.Uri.from(options.uri) });
                        wrapper = options.wrapper;
                        return [4 /*yield*/, wrapper.invoke(typedOptions, this)];
                    case 1:
                        invocableResult = _a.sent();
                        if (!invocableResult.ok) {
                            return [2 /*return*/, (0, result_1.ResultErr)(invocableResult.error)];
                        }
                        value = invocableResult.value;
                        if (options.encodeResult && !invocableResult.encoded) {
                            encoded = (0, msgpack_js_1.msgpackEncode)(value);
                            return [2 /*return*/, (0, result_1.ResultOk)(encoded)];
                        }
                        else if (invocableResult.encoded && !options.encodeResult) {
                            decoded = (0, msgpack_js_1.msgpackDecode)(value);
                            return [2 /*return*/, (0, result_1.ResultOk)(decoded)];
                        }
                        else {
                            return [2 /*return*/, (0, result_1.ResultOk)(value)];
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        return [2 /*return*/, (0, result_1.ResultErr)(error_1)];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // $start: PolywrapCoreClient-invoke
    /**
     * Invoke a wrapper.
     *
     * @remarks
     * Unlike `invokeWrapper`, this method automatically retrieves and caches the wrapper.
     *
     * @param options - {
     *   // The Wrapper's URI
     *   uri: TUri;
     *
     *   // Method to be executed.
     *   method: string;
     *
     *   //Arguments for the method, structured as a map, removing the chance of incorrectly ordered arguments.
     *    args?: Record<string, unknown> | Uint8Array;
     *
     *   // Env variables for the wrapper invocation.
     *    env?: Record<string, unknown>;
     *
     *   // A Uri resolution context
     *   resolutionContext?: IUriResolutionContext;
     *
     *   // if true, return value is a msgpack-encoded byte array
     *   encodeResult?: boolean;
     * }
     * @returns A Promise with a Result containing the return value or an error
     */
    PolywrapCoreClient.prototype.invoke = function (options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var typedOptions, resolutionContext, loadWrapperContext, loadWrapperResult, resolutionPath, resolvedUri, wrapper, env, invokeContext, invokeResult, error_2;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 3, , 4]);
                        typedOptions = __assign(__assign({}, options), { uri: core_js_1.Uri.from(options.uri) });
                        resolutionContext = (_a = options.resolutionContext) !== null && _a !== void 0 ? _a : new core_js_1.UriResolutionContext();
                        loadWrapperContext = resolutionContext.createSubContext();
                        return [4 /*yield*/, this.loadWrapper(typedOptions.uri, loadWrapperContext)];
                    case 1:
                        loadWrapperResult = _c.sent();
                        if (!loadWrapperResult.ok) {
                            resolutionContext.trackStep({
                                sourceUri: typedOptions.uri,
                                result: core_js_1.UriResolutionResult.err(loadWrapperResult.error),
                                description: "Client.loadWrapper",
                                subHistory: loadWrapperContext.getHistory(),
                            });
                            return [2 /*return*/, loadWrapperResult];
                        }
                        resolutionPath = loadWrapperContext.getResolutionPath();
                        resolutionPath =
                            resolutionPath.length > 0 ? resolutionPath : [typedOptions.uri];
                        resolvedUri = resolutionPath[resolutionPath.length - 1];
                        wrapper = loadWrapperResult.value;
                        resolutionContext.trackStep({
                            sourceUri: typedOptions.uri,
                            result: core_js_1.UriResolutionResult.ok(resolvedUri, loadWrapperResult.value),
                            description: "Client.loadWrapper",
                            subHistory: loadWrapperContext.getHistory(),
                        });
                        env = (_b = options.env) !== null && _b !== void 0 ? _b : (0, core_js_1.getEnvFromResolutionPath)(resolutionPath, this);
                        invokeContext = resolutionContext.createSubContext();
                        return [4 /*yield*/, this.invokeWrapper(__assign(__assign({}, typedOptions), { env: env, resolutionContext: invokeContext, wrapper: wrapper }))];
                    case 2:
                        invokeResult = _c.sent();
                        resolutionContext.trackStep({
                            sourceUri: resolvedUri,
                            result: invokeResult.ok
                                ? core_js_1.UriResolutionResult.ok(resolvedUri)
                                : (0, result_1.ResultErr)(invokeResult.error),
                            description: "Client.invokeWrapper",
                            subHistory: invokeContext.getHistory(),
                        });
                        if (!invokeResult.ok) {
                            return [2 /*return*/, invokeResult];
                        }
                        return [2 /*return*/, invokeResult];
                    case 3:
                        error_2 = _c.sent();
                        return [2 /*return*/, (0, result_1.ResultErr)(error_2)];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    // $start: PolywrapCoreClient-tryResolveUri
    /**
     * Resolve a URI to a wrap package, a wrapper, or a uri
     *
     * @param options - { uri: TUri; resolutionContext?: IUriResolutionContext }
     * @returns A Promise with a Result containing either a wrap package, a wrapper, or a URI if successful
     */
    PolywrapCoreClient.prototype.tryResolveUri = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var uri, uriResolver, resolutionContext, response;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        uri = core_js_1.Uri.from(options.uri);
                        uriResolver = this.getResolver();
                        resolutionContext = (_a = options.resolutionContext) !== null && _a !== void 0 ? _a : new core_js_1.UriResolutionContext();
                        return [4 /*yield*/, uriResolver.tryResolveUri(uri, this, resolutionContext)];
                    case 1:
                        response = _b.sent();
                        return [2 /*return*/, response];
                }
            });
        });
    };
    // $start: PolywrapCoreClient-loadWrapper
    /**
     * Resolve a URI to a wrap package or wrapper.
     * If the URI resolves to wrap package, load the wrapper.
     *
     * @remarks
     * Unlike other methods, `loadWrapper` does not accept a string URI.
     * You can create a Uri (from the `@polywrap/core-js` package) using `Uri.from("wrap://...")`
     *
     * @param uri - the Uri to resolve
     * @param resolutionContext? - a resolution context
     * @param options - { noValidate?: boolean }
     * @returns A Promise with a Result containing a Wrapper or Error
     */
    PolywrapCoreClient.prototype.loadWrapper = function (uri, resolutionContext, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var result, history_1, error, uriPackageOrWrapper, message, history_2, error, result_2, error;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!resolutionContext) {
                            resolutionContext = new core_js_1.UriResolutionContext();
                        }
                        return [4 /*yield*/, this.tryResolveUri({
                                uri: uri,
                                resolutionContext: resolutionContext,
                            })];
                    case 1:
                        result = _b.sent();
                        if (!result.ok) {
                            history_1 = (0, core_js_1.buildCleanUriHistory)(resolutionContext.getHistory());
                            error = void 0;
                            if (result.error) {
                                error = new core_js_1.WrapError("A URI Resolver returned an error.", {
                                    code: core_js_1.WrapErrorCode.URI_RESOLVER_ERROR,
                                    uri: uri.uri,
                                    resolutionStack: history_1,
                                    cause: result.error,
                                });
                            }
                            else {
                                error = new core_js_1.WrapError("Error resolving URI", {
                                    code: core_js_1.WrapErrorCode.URI_RESOLUTION_ERROR,
                                    uri: uri.uri,
                                    resolutionStack: history_1,
                                });
                            }
                            return [2 /*return*/, (0, result_1.ResultErr)(error)];
                        }
                        uriPackageOrWrapper = result.value;
                        if (uriPackageOrWrapper.type === "uri") {
                            message = "Unable to find URI ".concat(uriPackageOrWrapper.uri.uri, ".");
                            history_2 = (0, core_js_1.buildCleanUriHistory)(resolutionContext.getHistory());
                            error = new core_js_1.WrapError(message, {
                                code: core_js_1.WrapErrorCode.URI_NOT_FOUND,
                                uri: uri.uri,
                                resolutionStack: history_2,
                            });
                            return [2 /*return*/, (0, result_1.ResultErr)(error)];
                        }
                        if (!(uriPackageOrWrapper.type === "package")) return [3 /*break*/, 3];
                        return [4 /*yield*/, uriPackageOrWrapper.package.createWrapper(options)];
                    case 2:
                        result_2 = _b.sent();
                        if (!result_2.ok) {
                            error = new core_js_1.WrapError((_a = result_2.error) === null || _a === void 0 ? void 0 : _a.message, {
                                code: core_js_1.WrapErrorCode.CLIENT_LOAD_WRAPPER_ERROR,
                                uri: uri.uri,
                                cause: result_2.error,
                            });
                            return [2 /*return*/, (0, result_1.ResultErr)(error)];
                        }
                        return [2 /*return*/, (0, result_1.ResultOk)(result_2.value)];
                    case 3: return [2 /*return*/, (0, result_1.ResultOk)(uriPackageOrWrapper.wrapper)];
                }
            });
        });
    };
    return PolywrapCoreClient;
}());
exports.PolywrapCoreClient = PolywrapCoreClient;
//# sourceMappingURL=PolywrapCoreClient.js.map